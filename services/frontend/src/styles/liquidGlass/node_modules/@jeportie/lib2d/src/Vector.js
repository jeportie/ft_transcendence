// ************************************************************************** //
//                                                                            //
//                                                        :::      ::::::::   //
//   Vector.js                                          :+:      :+:    :+:   //
//                                                    +:+ +:+         +:+     //
//   By: jeportie <jeportie@42.fr>                  +#+  +:+       +#+        //
//                                                +#+#+#+#+#+   +#+           //
//   Created: 2025/08/04 18:25:36 by jeportie          #+#    #+#             //
//   Updated: 2025/08/20 14:07:36 by jeportie         ###   ########.fr       //
//                                                                            //
// ************************************************************************** //

import Coord from "./Coord.js"

/**
 * Represents a 2D vector with magnitude and direction, extending Coord.
 * @extends Coord
 */
export default class Vector extends Coord {

    /**
     * Factory: create a Vector from raw x,y.
     * @param {number} x
     * @param {number} y
     * @returns {Vector}
     */
    static from(x, y) {
        return new Vector(x, y);
    }

    /**
     * Gets the magnitude (length) of the vector.
     * @type {number}
     */
    get magnitude() {
        return Math.hypot(this.x, this.y);
    }

    /**
     * Returns a new normalized (unit length) vector in the same direction.
     * @returns {Vector} A new Vector with magnitude 1 (or zero vector if original is zero).
     */
    normalize() {
        const mag = this.magnitude || 1;
        return new Vector(this.x / mag, this.y / mag);
    }

    /**
     * Returns a new vector with its Y component inverted.
     * @returns {Vector} A new Vector reflected over the X-axis.
     */
    invertY() {
        return new Vector(this.x, -this.y);
    }

    /**
     * Returns a new vector with its X component inverted.
     * @returns {Vector} A new Vector reflected over the Y-axis.
     */
    invertX() {
        return new Vector(-this.x, this.y);
    }

    /** Create a new unit vector from an angle (in radians) */
    static fromAngle(angle) {
        return new Vector(Math.cos(angle), Math.sin(angle));
    }

    /** Rotate this vector (mutating) */
    rotateSelf(angleRad) {
        const cos = Math.cos(angleRad);
        const sin = Math.sin(angleRad);
        const x = this.x * cos - this.y * sin;
        const y = this.x * sin + this.y * cos;
        this.x = x;
        this.y = y;
        return this;
    }

    /**
     * Rotates the vector by a given angle around the origin.
     * @param {number} angleRad - The rotation angle in radians.
     * @returns {Vector} A new Vector representing the rotated vector.
     */
    rotate(angleRad) {
        const cos = Math.cos(angleRad);
        const sin = Math.sin(angleRad);
        return new Vector(
            this.x * cos - this.y * sin,
            this.x * sin + this.y * cos
        );
    }

    /**
     * Returns a new vector with the same direction but a different magnitude.
     * @param {number} newMag - The desired magnitude for the new vector.
     * @returns {Vector} A new Vector scaled to the specified magnitude.
     */
    withMagnitude(newMag) {
        return this.normalize().scale(newMag);
    }

    /**
     * Computes the dot product between this vector and another.
     * @param {Vector} other - The other vector.
     * @returns {number} The scalar dot product (this · other).
     */
    dot(other) {
        if (!(other instanceof Vector)) {
            throw new TypeError("Vector.dot requires a Vector");
        }
        return this.x * other.x + this.y * other.y;
    }

    /**
     * Computes the 2D cross product (scalar) between this vector and another.
     * @param {Vector} other - The other vector.
     * @returns {number} The scalar cross product (this × other) in 2D.
     */
    cross(other) {
        if (!(other instanceof Vector)) {
            throw new TypeError("Vector.cross requires a Vector");
        }
        return this.x * other.y - this.y * other.x;
    }

    /**
     * Renders this vector as an arrow from an origin point (ox, oy).
     * If no origin is provided, the vector is drawn from (0,0).
     * @param {CanvasRenderingContext2D} ctx - The 2D drawing context.
     * @param {Object} [options] - Rendering options.
     * @param {number} [options.ox=0] - X coordinate of the origin.
     * @param {number} [options.oy=0] - Y coordinate of the origin.
     * @param {string} [options.strokeStyle="#0ff"] - Color of the arrow line.
     * @param {number} [options.lineWidth=2] - Thickness of the arrow line.
     * @param {number} [options.headSize=8] - Size of the arrow head.
     * @returns {void}
     */
    render(ctx, { ox = 0, oy = 0, color = "#0ff", lineWidth = 2, headSize = 8 } = {}) {
        // draw line
        ctx.beginPath();
        ctx.moveTo(ox, oy);
        ctx.lineTo(ox + this.x, oy + this.y);
        ctx.strokeStyle = color;
        ctx.lineWidth = lineWidth;
        ctx.stroke();
        ctx.closePath();

        // draw head
        const angle = Math.atan2(this.y, this.x);
        const endX = ox + this.x;
        const endY = oy + this.y;
        ctx.beginPath();
        ctx.moveTo(endX, endY);
        ctx.lineTo(endX - headSize * Math.cos(angle - Math.PI / 6),
            endY - headSize * Math.sin(angle - Math.PI / 6));
        ctx.lineTo(endX - headSize * Math.cos(angle + Math.PI / 6),
            endY - headSize * Math.sin(angle + Math.PI / 6));
        ctx.lineTo(endX, endY);
        ctx.stroke();
        ctx.closePath();
    }

    /**
     * (Optional) Render only the vector endpoint as a single pixel (like Point).
     * Useful for a “pixel philosophy” debug view.
     * @param {CanvasRenderingContext2D} ctx
     * @param {Object} [options]
     * @param {number} [options.ox=0]
     * @param {number} [options.oy=0]
     * @param {string} [options.color="#fff"]
     * @returns {void}
     */
    renderAsPixel(ctx, { ox = 0, oy = 0, color = "#fff" } = {}) {
        ctx.fillStyle = color;
        ctx.fillRect(ox + this.x, oy + this.y, 1, 1);
    }

    /**
     * Reflect this vector on a horizontal or vertical wall, with optional angle adjustment.
     * @param {"x"|"y"} axis - Axis of reflection ("x" for vertical wall, "y" for horizontal wall).
     * @param {number} [angle=0] - Extra angle (in radians) to rotate the reflected vector.
     *        Positive = counter-clockwise, Negative = clockwise.
     * @returns {Vector} A new reflected and rotated vector.
     */
    reflect(axis, angle = 0) {
        let reflected;
        if (axis === "x") {
            reflected = new Vector(-this.x, this.y);
        } else if (axis === "y") {
            reflected = new Vector(this.x, -this.y);
        } else {
            throw new Error("Vector.reflect axis must be 'x' or 'y'");
        }

        if (angle !== 0) {
            reflected = reflected.rotate(angle);
        }
        return reflected;
    }
}

/* Optional sugar
 *
 *In Vector, you could add a .clone() alias for copy(), or a .toPoint() if you ever need to treat a vector as a point.
 * */
